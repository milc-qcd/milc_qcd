/************ eigen_stuff_Grid.c **************/
/* Eigenvalue and Eigevector computation routines.
 * This version uses Grid (https://github.com/paboyle/Grid)
 * MIMD version 7 */
/**********************************************/

#include "generic_ks_includes.h"
#include <string.h>
#include <assert.h>

#include "../include/generic_grid.h"
#include "../include/generic_ks_grid.h"

/* assigned in initialize_grid() */
extern GRID_4Dgrid * grid_full;
extern GRID_4DRBgrid * grid_rb;

/* #define EIG_DEBUG */
/* #define EIGTIME */

/* Compute eigenvalues and eigenvectors of the Kogut-Susskind
 * dslash^2. */
int ks_eigensolve_Grid( su3_vector ** eigVec,
                        Real * eigVal,
                        ks_eigen_param * eigen_param,
                        int init )
{
  char myname[] = "ks_eigensolve_Grid";
  int ii; /* loop index */

#ifdef EIG_DEBUG
  node0_printf( "%s: Start\n", myname );
#endif

  /* check Grid */
  if(! grid_initialized())
  {
    node0_printf( "%s: FATAL. Grid has not been initialized.\n", myname );
    terminate(1);
  }
  
#ifdef EIGTIME
  double dtimec;
#endif

  /* input parameters for Grid eigensolver **********************/
  int Nvecs = eigen_param->Nvecs;
  int Nvecs_in = eigen_param->Nvecs_in;
  int parity = eigen_param->parity;

  GRID_eig_arg_t eig_arg;

  eig_arg.Nstop = Nvecs;
  eig_arg.Nk = ( eigen_param->Nrestart > 0 ) ? eigen_param->Nrestart : Nvecs*1.1;
  eig_arg.Nm = ( eigen_param->Nmax > 0 ) ? eigen_param->Nmax : Nvecs*1.3;
  assert( eig_arg.Nk >= eig_arg.Nstop );
  assert( eig_arg.Nm > eig_arg.Nk );

  if( eigen_param->tol > 0 ) eig_arg.tol = eigen_param->tol;
  else
  {
#if MILC_PRECISION == 1
    eig_arg.tol = 1e-5;
#else
    eig_arg.tol = 1e-12;
#endif
  }
  eig_arg.maxIter = ( eigen_param->MaxIter > 0 ) ? eigen_param->MaxIter : 100;
  eig_arg.reorth_period = ( eigen_param->reorth_period > 0 ) ? eigen_param->reorth_period : 1;
  eig_arg.restartMin = 0; /* fix to zero for the moment */

  /* parameters for Chebyshev polynomial */
  eig_arg.chebyParams.alpha = ( eigen_param->poly.minE > 0 ) ? eigen_param->poly.minE : 10;
  eig_arg.chebyParams.beta = ( eigen_param->poly.maxE > 0 ) ? eigen_param->poly.maxE : 100;
  eig_arg.chebyParams.Npoly = ( eigen_param->poly.norder ) ? eigen_param->poly.norder : 31;
  assert( eig_arg.chebyParams.alpha < eig_arg.chebyParams.beta );
  assert( eig_arg.chebyParams.Npoly % 2 == 1 ); /* Odd order Chebyshev corresponds to even order polynomial in Grid. */

  /* diagonalization algorithm */
  if( strcmp( "0", eigen_param->diagAlg ) == 0 ) sprintf( eigen_param->diagAlg, "Eigen" ); /* default */
  if( strcmp( "LAPACK", eigen_param->diagAlg ) == 0 ) eig_arg.diag = GRID_IRLdiagonaliseWithDSTEGR;
  else if( strcmp( "QR", eigen_param->diagAlg ) == 0 ) eig_arg.diag = GRID_IRLdiagonaliseWithQR;
  else if( strcmp( "Eigen", eigen_param->diagAlg ) == 0 ) eig_arg.diag = GRID_IRLdiagonaliseWithEigen;
  else
  {
    node0_printf( "%s: Unsupported diagonalization algorithm - %s\n", myname, eigen_param->diagAlg );
    terminate(1);
  }

  /* even-odd site parity */
  if( eigen_param->parity == ODD )
  {
    eig_arg.parity = GRID_ODD;
  }
  else /* default is even */
  {
    eig_arg.parity = GRID_EVEN;
  }

  /* End of ****** input parameters for Grid eigensolver */
  
  /* print input parameters for eigensolver ******************/
  node0_printf( "========= parameters for eigensolver =========\n" );
  node0_printf( "Number of wanted eigenvalues: %d\n", eig_arg.Nstop );
  node0_printf( "Maximum number of eigenvalues: %d\n", eig_arg.Nm );
  node0_printf( "Restarting number of eigenvalues: %d\n", eig_arg.Nk );
  node0_printf( "Eigenvalue equation tolerance: %e\n", eig_arg.tol );
  node0_printf( "Maximum iterations of Lanczos restarts: %d\n", eig_arg.maxIter );
  node0_printf( "Reorthogonalization period: %d\n", eig_arg.reorth_period );
  node0_printf( "Chebyshev polynomial - alpha (lower bound for exclusion): %g\n", eig_arg.chebyParams.alpha );
  node0_printf( "Chebyshev polynomial - beta (upper bound for exclusion): %g\n", eig_arg.chebyParams.beta );
  node0_printf( "Chebyshev polynomial order: %d\n", eig_arg.chebyParams.Npoly );
  node0_printf( "Diagonalization algorihm: %s\n", eigen_param->diagAlg );
  node0_printf( "Even-odd parity: %d\n", eigen_param->parity );
  node0_printf( "==============================================\n" );
  /* End of ********* print input parameters for eigensolver */

  double mass = 0;

  /* eigenvectors for Grid */
  GRID_ColorVectorArray * grid_eigVec = GRID_create_V_array_from_vec_array( eigVec, Nvecs, parity, grid_full, grid_rb );

  /* fermion links generated by create_fermion_links_from_site() */
  imp_ferm_links_t *fn = get_fm_links(fn_links)[0];
  GRID_FermionLinksAsqtad * links; /* share the same link structure with Asqtad */
  links = GRID_asqtad_create_L_from_MILC( NULL, get_fatlinks(fn), get_lnglinks(fn), grid_full );
  
#ifdef EIGTIME
  dtimec = -dclock();
#endif
#ifdef EIG_DEBUG
  node0_printf( "%s: Eigensolver starts.\n", myname );  
#endif

  /* Grid's eigensolver using implicitly restarted Lanczos algorithm */
  GRID_implicitly_restarted_lanczos( grid_eigVec, eigVal, links, &eig_arg, mass, grid_full, grid_rb );

#ifdef EIG_DEBUG
  node0_printf( "%s: Eigensolver ended.\n", myname );  
#endif
#ifdef EIGTIME
  dtimec += dclock();
  node0_printf( "[EIGTIME] Grid IRL: time = %g s\n", dtimec );
#endif

  /* copy Grid eigenvectors to MILC format */
  GRID_extract_V_array_to_vec_array( eigVec, Nvecs, grid_eigVec, parity );

  /* print eigenvalues */
  node0_printf( "BEGIN RESULTS\n" );
  for( ii=0; ii<Nvecs; ii+=1 )
  {
#ifdef EIG_DEBUG
    node0_printf( "Eigenvalue(%i) = %.15e \n", ii, eigVal[ii] );
#else
    node0_printf( "Eigenvalue(%i) = %g \n", ii, eigVal[ii] );
#endif
  }

  /* free **************/
  GRID_destroy_V_array( grid_eigVec );
  GRID_asqtad_destroy_L(links);
  /* End of ******* free */
  
#ifdef EIG_DEBUG
  node0_printf( "%s: End\n", myname );
#endif

  return 0;
}
